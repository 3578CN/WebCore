# WebCore 底层框架开发文档
* 开发语言：c# 12.0
* 开发环境：Visual Studio 2022
* 开发框架：.NET 8.0
* 可跨平台：WIndows、MacOSX、Linux

## 功能介绍
>WebUI          动态页面渲染  
WebSite         静态页解析  
Security        安全验证  
WebHandler      请求的处理程序接口  
Shared          工具类方法封装  

# 索引
[开发环境搭建](#kfhjdj)  
[生产环境搭建](#schjdj)  
[创建一个 Web 应用程序](#cjygyycx)  

[应用程序全局配置](#yycxqjpz)  
[编写动态页面代码](#bxdtymdm)  
[开发静态页面网站](#kfjtymdm)  
[用户登录的实现](#yhdldsx)  

[动态页面权限认证自定义扩展](#dtymqxrzzdykz)  
[动态页面控件自定义扩展](#dtymkjzdykz)  
[页面模板标签解析处理程序扩展](#ymmbbqjxclcxkz)  

[公共工具类的使用方法](#gggjldsyff)  
[SSL 数字证书的申请和配置](#ssl)  

[底层框架运行机制](#dckjyxjz)  
[开发流程图](#kflct)  
[兼容性以及跨平台部署](#jrxyjkptbs)  
[可能存在的问题](#knczdwt)  
[尚未完成的功能](#swwcdgn)  

## 开发环境搭建<span id="kfhjdj" />
## 生产环境搭建<span id="schjdj" />
    首次 Linux 服务器配置，按照顺序操作。
    用于 ASP.NET Core 8 的生产环境，适用于 CentOS Stream 9。

编辑以下文件保持 SSH 不掉线：
```bash
sudo nano /etc/ssh/sshd_config
```
在末尾添加以下内容：
```bash
ClientAliveInterval 60
ClientAliveCountMax 5
```
最后重启 SSH：
```bash
sudo systemctl restart sshd
```
---
更新服务器：
```bash
sudo yum -y update
```
---
安装 WEB 服务器：
```bash
sudo yum -y install nginx
sudo systemctl enable nginx.service
sudo service nginx start
```
设置站点（匿名）用户（与 SFTP 用户名相同）：
```bash
sudo useradd -d /var/www -s /sbin/nologin site
sudo passwd site
sudo chown -R site:site /var/www
```
创建目录：
```bash
/var/www/www.3578.cn
```
---
安装 ASP.NET Core 8 运行时：
```bash
sudo dnf -y install aspnetcore-runtime-8.0.x86_64
```
1. 创建站点配置文件：
```bash
sudo nano /etc/nginx/conf.d/3578.cn.conf
```
2. 添加以下内容：
```bash
server {
    listen 80;
    server_name 3578.cn www.3578.cn;

    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name 3578.cn www.3578.cn;

    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```
3. 重启 nginx：
```bash
sudo systemctl restart nginx
```
---
设置反向代理：
```bash
sudo nano /etc/systemd/system/kestrel-3578.cn.service
```
1. 添加以下内容：
```bash
[Unit]
Description=www.3578.cn Web Application

[Service]
WorkingDirectory=/var/www/www.3578.cn
ExecStart=/var/www/www.3578.cn/CBC.TestApp
Restart=always
# Restart service after 10 seconds if the dotnet service crashes:
RestartSec=10
KillSignal=SIGINT
SyslogIdentifier=www.3578.cn
User=www-data
Environment=ASPNETCORE_ENVIRONMENT=Production
Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false

[Install]
WantedBy=multi-user.target
```
2. 添加并启动服务：
```bash
sudo systemctl enable kestrel-3578.cn.service
sudo systemctl start kestrel-3578.cn.service

sudo systemctl status kestrel-3578.cn.service
```
3. 设置文件可执行：
```bash
sudo chmod +x /var/www/www.3578.cn/CBC.TestApp
```
4. 简化网站重启方法：

创建脚本（免去 .sh 扩展名）。
```bash
mkdir /var/www/sh
nano /var/www/sh/3578sh
```
5. 添加以下内容：
```bash
#!/bin/bash
echo "开始重启网站： www.3578.cn"
sudo chmod +x /var/www/www.3578.cn/CBC.TestApp && sudo systemctl restart kestrel-3578.cn.service && sleep 1 && sudo systemctl status kestrel-3578.cn.service
echo "网站重启完成！"
```
6. 把脚本加入环境变量：
```bash
echo 'export PATH=$PATH:/var/www/sh' >> ~/.bashrc
source ~/.bashrc
```
这样以后在任何位置都可以运行 3578sh 来重启网站。

---
设置 SSH 站点连接用户权限：
```bash
sudo chown root:root /var/www
sudo chmod 755 /var/www
sudo chmod 777 /var/www/www.3578.cn
```
1. 编辑 SSH 配置文件：
```bash
sudo nano /etc/ssh/sshd_config
```
2. 在最后添加以下内容：
```bash
Match User site
  ChrootDirectory /var/www
  ForceCommand internal-sftp
  AllowTcpForwarding no
  X11Forwarding no
```
3. 重启 SSH：
```bash
sudo systemctl restart sshd
```
---
安装MySQL：
1. 更新系统：
```bash
sudo dnf update -y
```
2. 安装 MySQL 存储库：
```bash
sudo dnf install -y https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm
```
3. 安装 MySQL：
```bash
sudo dnf install -y mysql-community-server --nogpgcheck
```
4. 启动 MySQL 服务：
```bash
sudo systemctl start mysqld
sudo systemctl enable mysqld
```
5. 初始化 MySQL：
```bash
sudo grep 'temporary password' /var/log/mysqld.log
```
    该命令会输出类似以下内容：
    2024-08-03T16:04:21.862303Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: VhdZzrBZx4(y

6. 安全设置：
```
使用 mysql_secure_installation 命令进行安全设置，包括设置 root 密码、删除匿名用户、禁止 root 远程登录以及删除测试数据库等。
过程中会提示输入临时密码，并设置一个新的 root 密码。
```
```bash
sudo mysql_secure_installation
```
7. 登录 MySQL：
```bash
mysql -u root -p
```
## 创建一个 Web 应用程序<span id="cjygyycx" />
1. 启动 Visual Studio 2022。
1. 新建项目 ASP.NET Core Web 空项目，框架选择 .NET 8.0。
1. 添加 CBC.WebCore DLL 引用，修改 .csproj 文件：
```xml
  <ItemGroup>
    <Reference Include="CBC.WebCore">
      <HintPath>你的 WebCore.dll 路径\CBC.WebCore.dll</HintPath> 
    </Reference>
  </ItemGroup>
```
4. 添加 - 新建项 - 启动类 Startup.cs。
1. 修改 Startup.cs 类的代码为：
```csharp
using CBC.WebCore.Common;

namespace 你的命名空间
{
    public class Startup : CBCStartup
    {
        // 构造函数，传递 IConfiguration 实例到基类 CBCStartup 中。
        public Startup(IConfiguration configuration) : base(configuration)
        {
        }

        // 重写 ConfigureServices 方法以注册服务到依赖注入容器中，若有需要可以在此基础上添加更多服务。
        public override void ConfigureServices(IServiceCollection services)
        {
            base.ConfigureServices(services); // 调用基类方法以确保基类的服务配置被应用。
        }

        // 重写 Configure 方法以配置应用程序的中间件管道，若有需要可以在此基础上添加更多中间件。
        public override void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory? log = null)
        {
            base.Configure(app, env, loggerFactory);

            // 注册终结点路由中间件。
            app.UseEndpointRouting("Endpoints", "Index");
        }
    }
}
```
6. 替换 Program.cs 类的代码为：
```csharp
using 你的命名空间;

var builder = WebApplication.CreateBuilder(args);

var startup = new Startup(builder.Configuration);
startup.ConfigureServices(builder.Services);

var app = builder.Build();

startup.Configure(app, app.Environment);

app.Run();
```
## 应用程序全局配置<span id="yycxqjpz" />
编辑 appsettings.json 文件，替换成下面的内容：
```json
{
  // 引用 JSON Schema。
  "$schema": "http://www.3578.cn/json-schema/webcore-schema.json",

  // 网站配置。
  "webSettings": {
    // 站点独立路由配置，每个站点的 host 对应其配置文件。
    "routing": [
      {
        "host": "你的站点的域名", // 站点的域名。
        "configFile": "你的站点配置 XML 文件" // 该站点对应的配置文件路径。
      }
    ],
    // 用户界面模板配置，指定模板的路径。
    "uiTemplates": {
      "templatePath": "/", // 用户界面模板的根路径。
      "pagerTemplatePath": "/" // 分页模板的根路径。
    },
    // 数据库连接字符串配置，包含多个数据库连接信息。
    "databaseConnections": [
      {
        "name": "[你的数据库名]", // 应用测试数据库连接的名称。
        "connectionString": "[你的数据库连接字符串]" // 应用测试数据库的连接字符串。
      }
    ]
  },
  // 安全配置。
  "security": {
    "type": "", // 安全配置的类型（留空使用默认安全验证处理程序）。
    // 登录页面路径配置。
    "login": {
      "path": "/Account/Login" // 登录页面的路径。
    },
    // 需要授权访问的路径配置。
    "authorizedPaths": [
      {
        "path": "/Account/" // 需要授权访问的路径。
      }
    ],
    // 无需授权即可访问的路径配置。
    "unrestrictedPaths": [
      {
        "path": "/Account/LoginAuth" // 无需授权即可访问的路径。
      }
    ],
    // 静态页面管理的 IP 地址配置。
    "staticPageManagementIPs": [
      {
        "ip": "0.0.0.0", // 允许管理静态页面的 IP 地址。
        "mask": "255.255.255.255" // 对应的子网掩码。
      }
    ]
  },
  // 静态页文件自动更新配置。
  "autoUpdate": {
    "interval": 3600, // 自动更新的时间间隔，单位为秒。
    // 监视器配置，定义监视文件变化的规则。
    "watchers": [
      {
        "eventTypes": [ "Changed", "Created", "Deleted", "Renamed" ], // 监视的事件类型，包括更改、创建、删除和重命名。
        "path": "/", // 监视的路径。
        "includeSubDirectories": true // 是否包含子目录。
      }
    ],
    // 页面匹配规则，定义哪些页面需要自动更新。
    "rules": [
      {
        "pattern": "index.htm", // 匹配页面的正则表达式，用于识别要更新的页面。
        "path": "/", // 适用于匹配规则的路径。
        "includeSubDirectories": true, // 是否包含子目录。
        "interval": 3600 // 自动更新的时间间隔，单位为秒。
      }
    ]
  }
}
```
## 编写动态页面代码<span id="bxdtymdm" />

1. 根目录下添加两个目录 Endpoints、Template。
1. 在 Template 目录下新建 Index.html 页面模板：
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>CBC WebCore 测试页面</title>
</head>
<body>
    <p>Hello World!</p>
</body>
</html>
```
3. 在 Endpoints 目录下添加类 Index。
1. 该类需要继承 CBC.WebCore.WebUI.Page 类，并加入下面的 Load() 方法：
```csharp
public class Index : Page
{
    // 同步方法。
    protected void LoadAsync()
    {
        Main.Template = "Index.html";
    }
}
```
```csharp
public class Index : Page
{
    // 异步方法。
    protected async Task LoadAsync(HttpContext context)
    {
        await context.Response.WriteAsync("Hello World!");
    }
}
```
## 开发静态页面网站<span id="kfjtymdm" />
1. 根目录下添加目录 Handlers。
1. 设置中间件。
```csharp
// Startup.cs 注册静态页处理中间件。
app.UseStaticPage();
```
1. 编写一个页面模板：
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>标签解析框架测试页面</title>
    <style>
        /* 自定义简化样式 - 单行模式 */
        body { font-family: Arial, sans-serif; background-color: #f3f3f3; margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; } 
        .container { background-color: #fff; border: 1px solid #ccc; padding: 20px; max-width: 600px; width: 100%; } 
        h1 { font-size: 24px; margin-bottom: 16px; } 
        p { font-size: 16px; margin-bottom: 12px; } 
        .parser-output { font-style: italic; color: #555; border: 1px dashed #ccc; padding: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>标签解析框架测试页面</h1>
        <!-- 解析内容 -->
        <p class="parser-output">标题：{$Title}</p>
        <p class="parser-output">内容：{$Content}</p>
    </div>
    {$Data(CBC.TestApp.Handlers.Index_Parser):type=a;}
</body>
</html>
```
2. 在 Handlers 目录里，添加标签处理类 Index_Parser.cs：
```csharp
using System.Text;
using CBC.WebCore.Common;
using CBC.WebCore.WebSite.Parsers;
using CBC.WebCore.WebSite.Parsers.ParserImpls;
using CBC.WebCore.WebSite.Parsers.TagsEntity;

namespace CBC.TestApp.Handlers
{
    public class Index_Parser : IParser
    {
        public async Task ParseAsync(HttpContext context, StringBuilder pageHtml, DataTags dataTags)
        {
            var mysql = new WebCore.Common.DataHelpers.MySqlHelper(AppSettings.Current.ConnectionStrings["AppTestDB"]);
            var table = mysql.GetDataTable("SELECT * FROM Content where id=5");

            var page = new PageParserImpl(dataTags);
            await page.ParseAsync(context, pageHtml, dataTags, table);
        }
    }
}
```
